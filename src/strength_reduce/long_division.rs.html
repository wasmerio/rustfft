<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/strength_reduce-0.2.4/src/long_division.rs`."><title>long_division.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-e5308b57e507db71.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-d59023bfa12059d2.css"><link rel="stylesheet" disabled href="../../static.files/dark-1ca41bb1e10af075.css"><link rel="stylesheet" disabled href="../../static.files/ayu-18b4181a2f3fb862.css"><script src="../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../../static.files/source-script-1b95b7cca98b26e5.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../strength_reduce/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
</pre><pre class="rust"><code><span class="kw">extern crate </span>core;

<span class="kw">const </span>U32_MAX: u64 = core::u32::MAX <span class="kw">as </span>u64;
<span class="kw">const </span>U64_MAX: u128 = core::u64::MAX <span class="kw">as </span>u128;

<span class="kw">use </span>::StrengthReducedU64;
<span class="kw">use </span>::long_multiplication;

<span class="comment">// divides a 128-bit number by a 64-bit divisor, returning the quotient as a 64-bit number
// assumes that the divisor and numerator have both already been bit-shifted so that divisor.leading_zeros() == 0
</span><span class="attr">#[inline]
</span><span class="kw">fn </span>divide_128_by_64_preshifted(numerator_hi: u64, numerator_lo: u64, divisor: u64) -&gt; u64 {
    <span class="kw">let </span>numerator_mid = (numerator_lo &gt;&gt; <span class="number">32</span>) <span class="kw">as </span>u128;
    <span class="kw">let </span>numerator_lo = numerator_lo <span class="kw">as </span>u32 <span class="kw">as </span>u128;
    <span class="kw">let </span>divisor_full_128 = divisor <span class="kw">as </span>u128;
    <span class="kw">let </span>divisor_hi = divisor &gt;&gt; <span class="number">32</span>;

    <span class="comment">// To get the upper 32 bits of the quotient, we want to divide &#39;full_upper_numerator&#39; by &#39;divisor&#39;
    // but the problem is, full_upper_numerator is a 96-bit number, meaning we would need to use u128 to do the division all at once, and the whole point of this is that we don&#39;t want to do 128 bit divison because it&#39;s slow
	// so instead, we&#39;ll shift both the numerator and divisor right by 32, giving us a 64 bit / 32 bit division. This won&#39;t give us the exact quotient -- but it will be close.
    </span><span class="kw">let </span>full_upper_numerator = ((numerator_hi <span class="kw">as </span>u128) &lt;&lt; <span class="number">32</span>) | numerator_mid;
    <span class="kw">let </span><span class="kw-2">mut </span>quotient_hi = core::cmp::min(numerator_hi / divisor_hi, U32_MAX);
    <span class="kw">let </span><span class="kw-2">mut </span>product_hi = quotient_hi <span class="kw">as </span>u128 * divisor_full_128;

    <span class="comment">// quotient_hi contains our guess at what the quotient is! the problem is that we got this by ignoring the lower 32 bits of the divisor. when we account for that, the quotient might be slightly lower
    // we will know our quotient is too high if quotient * divisor &gt; numerator. if it is, decrement until it&#39;s in range
    </span><span class="kw">while </span>product_hi &gt; full_upper_numerator {
        quotient_hi -= <span class="number">1</span>;
        product_hi -= divisor_full_128;
    }
    <span class="kw">let </span>remainder_hi = full_upper_numerator - product_hi;


    <span class="comment">// repeat the process using the lower half of the numerator
    </span><span class="kw">let </span>full_lower_numerator = (remainder_hi &lt;&lt; <span class="number">32</span>) | numerator_lo;
    <span class="kw">let </span><span class="kw-2">mut </span>quotient_lo = core::cmp::min((remainder_hi <span class="kw">as </span>u64) / divisor_hi, U32_MAX);
    <span class="kw">let </span><span class="kw-2">mut </span>product_lo = quotient_lo <span class="kw">as </span>u128 * divisor_full_128;

    <span class="comment">// again, quotient_lo is just a guess at this point, it might be slightly too large
    </span><span class="kw">while </span>product_lo &gt; full_lower_numerator {
        quotient_lo -= <span class="number">1</span>;
        product_lo -= divisor_full_128;
    }

    <span class="comment">// We now have our separate quotients, now we just have to add them together
    </span>(quotient_hi &lt;&lt; <span class="number">32</span>) | quotient_lo
}

<span class="comment">// divides a 128-bit number by a 64-bit divisor, returning the quotient as a 64-bit number
// assumes that the divisor and numerator have both already been bit-shifted to maximize the number of bits in divisor_hi
// divisor_hi should be the upper 32 bits, and divisor_lo should be the lower 32 bits
</span><span class="attr">#[inline]
</span><span class="kw">fn </span>divide_128_by_64_preshifted_reduced(numerator_hi: u64, numerator_lo: u64, divisor_hi: StrengthReducedU64, divisor_full: u64) -&gt; u64 {
    <span class="kw">let </span>numerator_mid = (numerator_lo &gt;&gt; <span class="number">32</span>) <span class="kw">as </span>u128;
    <span class="kw">let </span>numerator_lo = numerator_lo <span class="kw">as </span>u32 <span class="kw">as </span>u128;
    <span class="kw">let </span>divisor_full_128 = divisor_full <span class="kw">as </span>u128;

    <span class="comment">// To get the upper 32 bits of the quotient, we want to divide &#39;full_upper_numerator&#39; by &#39;divisor&#39;
    // but the problem is, full_upper_numerator is a 96-bit number, meaning we would need to use u128 to do the division all at once, and the whole point of this is that we don&#39;t want to do 128 bit divison because it&#39;s slow
	// so instead, we&#39;ll shift both the numerator and divisor right by 32, giving us a 64 bit / 32 bit division. This won&#39;t give us the exact quotient -- but it will be close.
    </span><span class="kw">let </span>full_upper_numerator = ((numerator_hi <span class="kw">as </span>u128) &lt;&lt; <span class="number">32</span>) | numerator_mid;
    <span class="kw">let </span><span class="kw-2">mut </span>quotient_hi = core::cmp::min(numerator_hi / divisor_hi, U32_MAX);
    <span class="kw">let </span><span class="kw-2">mut </span>product_hi = quotient_hi <span class="kw">as </span>u128 * divisor_full_128;

    <span class="comment">// quotient_hi contains our guess at what the quotient is! the problem is that we got this by ignoring the lower 32 bits of the divisor. when we account for that, the quotient might be slightly lower
    // we will know our quotient is too high if quotient * divisor &gt; numerator. if it is, decrement until it&#39;s in range
    </span><span class="kw">while </span>product_hi &gt; full_upper_numerator {
        quotient_hi -= <span class="number">1</span>;
        product_hi -= divisor_full_128;
    }
    <span class="kw">let </span>full_upper_remainder = full_upper_numerator - product_hi;


    <span class="comment">// repeat the process using the lower half of the numerator
    </span><span class="kw">let </span>full_lower_numerator = (full_upper_remainder &lt;&lt; <span class="number">32</span>) | numerator_lo;
    <span class="kw">let </span><span class="kw-2">mut </span>quotient_lo = core::cmp::min((full_upper_remainder <span class="kw">as </span>u64) / divisor_hi, U32_MAX);
    <span class="kw">let </span><span class="kw-2">mut </span>product_lo = quotient_lo <span class="kw">as </span>u128 * divisor_full_128;

    <span class="comment">// again, quotient_lo is just a guess at this point, it might be slightly too large
    </span><span class="kw">while </span>product_lo &gt; full_lower_numerator {
        quotient_lo -= <span class="number">1</span>;
        product_lo -= divisor_full_128;
    }

    <span class="comment">// We now have our separate quotients, now we just have to add them together
    </span>(quotient_hi &lt;&lt; <span class="number">32</span>) | quotient_lo
}

<span class="comment">// divides a 128-bit number by a 128-bit divisor
</span><span class="kw">pub fn </span>divide_128(numerator: u128, divisor: u128) -&gt; u128 {
	<span class="kw">if </span>divisor &lt;= U64_MAX {
		<span class="kw">let </span>divisor64 = divisor <span class="kw">as </span>u64;
		<span class="kw">let </span>upper_numerator = (numerator &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64;
		<span class="kw">if </span>divisor64 &gt; upper_numerator {
			divide_128_by_64_helper(numerator, divisor64) <span class="kw">as </span>u128
		}
		<span class="kw">else </span>{
			<span class="kw">let </span>upper_quotient = upper_numerator / divisor64;
			<span class="kw">let </span>upper_remainder = upper_numerator - upper_quotient * divisor64;

			<span class="kw">let </span>intermediate_numerator = ((upper_remainder <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>) | (numerator <span class="kw">as </span>u64 <span class="kw">as </span>u128);
			<span class="kw">let </span>lower_quotient = divide_128_by_64_helper(intermediate_numerator, divisor64);

			((upper_quotient <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>) | (lower_quotient <span class="kw">as </span>u128)
		}
	}
	<span class="kw">else </span>{
		<span class="kw">let </span>shift_size = divisor.leading_zeros();
		<span class="kw">let </span>shifted_divisor = divisor &lt;&lt; shift_size;

		<span class="kw">let </span>shifted_numerator = numerator &gt;&gt; <span class="number">1</span>;

		<span class="kw">let </span>upper_quotient = divide_128_by_64_helper(shifted_numerator, (shifted_divisor &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64);
		<span class="kw">let </span><span class="kw-2">mut </span>quotient = upper_quotient &gt;&gt; (<span class="number">63 </span>- shift_size);
		<span class="kw">if </span>quotient &gt; <span class="number">0 </span>{
			quotient -= <span class="number">1</span>;
		}

		<span class="kw">let </span>remainder = numerator - quotient <span class="kw">as </span>u128 * divisor;
		<span class="kw">if </span>remainder &gt;= divisor {
			quotient += <span class="number">1</span>;
		}
		quotient <span class="kw">as </span>u128
	}
}

<span class="comment">// divides a 128-bit number by a 64-bit divisor, returning the quotient as a 64-bit number. Panics if the quotient doesn&#39;t fit in a 64-bit number
</span><span class="kw">fn </span>divide_128_by_64_helper(numerator: u128, divisor: u64) -&gt; u64 {
	<span class="comment">// Assert that the upper half of the numerator is less than the denominator. This will guarantee that the quotient fits inside the numerator.
	// Sadly this will give us some false negatives! TODO: Find a quick test we can do that doesn&#39;t have false negatives
	// false negative example: numerator = u64::MAX * u64::MAX / u64::MAX
	</span><span class="macro">assert!</span>(divisor &gt; (numerator &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64, <span class="string">&quot;The numerator is too large for the denominator; the quotient might not fit inside a u64.&quot;</span>);

	<span class="kw">if </span>divisor &lt;= U32_MAX {
		<span class="kw">return </span>divide_128_by_32_helper(numerator, divisor <span class="kw">as </span>u32);
	}

    <span class="kw">let </span>shift_size = divisor.leading_zeros();
	<span class="kw">let </span>shifted_divisor = divisor &lt;&lt; shift_size;
	<span class="kw">let </span>shifted_numerator = numerator &lt;&lt; shift_size;
	<span class="kw">let </span>divisor_hi = shifted_divisor &gt;&gt; <span class="number">32</span>;
    <span class="kw">let </span>divisor_lo = shifted_divisor <span class="kw">as </span>u32 <span class="kw">as </span>u64;

    <span class="comment">// split the numerator into 3 chunks: the top 64-bits, the next 32-bits, and the lowest 32-bits
    </span><span class="kw">let </span>numerator_hi : u64 = (shifted_numerator &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64;
    <span class="kw">let </span>numerator_mid : u64 = (shifted_numerator &gt;&gt; <span class="number">32</span>) <span class="kw">as </span>u32 <span class="kw">as </span>u64;
    <span class="kw">let </span>numerator_lo : u64 = shifted_numerator <span class="kw">as </span>u32 <span class="kw">as </span>u64;

    <span class="comment">// we&#39;re essentially going to do a long division algorithm with 2 divisions, one on numerator_hi &lt;&lt; 32 | numerator_mid, and the second on the remainder of the first | numerator_lo
    // but numerator_hi &lt;&lt; 32 | numerator_mid is a 96-bit number, and we only have 64 bits to work with. so instead we split the divisor into 2 chunks, and divde by the upper chunk, and then check against the lower chunk in a while loop

    // step 1: divide the top chunk of the numerator by the divisor
    // IDEALLY, we would divide (numerator_hi &lt;&lt; 32) | numerator_mid by shifted_divisor, but that would require a 128-bit numerator, which is the whole thing we&#39;re trying to avoid
    // so instead we&#39;re going to split the second division into two sub-phases. in 1a, we divide numerator_hi by divisor_hi, and then in 1b we decrement the quotient to account for the fact that it&#39;ll be smaller when you take divisor_lo into account

    // keep in mind that for all of step 2, the full numerator we&#39;re using will be
    // complete_first_numerator  = (numerator_midbits &lt;&lt; 32) | numerator_mid

    // step 1a: divide the upper part of the middle numerator by the upper part of the divisor
    </span><span class="kw">let </span><span class="kw-2">mut </span>quotient_hi = core::cmp::min(numerator_hi / divisor_hi, U32_MAX);
    <span class="kw">let </span><span class="kw-2">mut </span>partial_remainder_hi = numerator_hi - quotient_hi * divisor_hi;

    <span class="comment">// step 1b: we know sort of what the quotient is, but it&#39;s slightly too large because it doesn&#39;t account for divisor_lo, nor numerator_mid, so decrement the quotient until it fits
    // note that if we do some algebra on the condition in this while loop,
    // ie &quot;quotient_hi * divisor_lo &gt; (partial_remainder_hi &lt;&lt; 32) | numerator_mid&quot;
    // we end up getting &quot;quotient_hi * shifted_divisor &lt; (numerator_midbits &lt;&lt; 32) | numerator_mid&quot;. remember that the right side of the inequality sign is complete_first_numerator from above.
    // which deminstrates that we&#39;re decrementing the quotient until the quotient multipled by the complete divisor is less than the complete numerator
    </span><span class="kw">while </span>partial_remainder_hi &lt;= U32_MAX &amp;&amp; quotient_hi * divisor_lo &gt; (partial_remainder_hi &lt;&lt; <span class="number">32</span>) | numerator_mid {
        quotient_hi -= <span class="number">1</span>;
        partial_remainder_hi += divisor_hi;
    }

    <span class="comment">// step 2: Divide the bottom part of the numerator. We&#39;re going to have the same problem as step 1, where we want the numerator to be a 96-bit number, so again we&#39;re going to split it into 2 substeps
	// the full numeratoe for step 3 will be:
	// complete_second_numerator = (first_division_remainder &lt;&lt; 32) | numerator_lo

    // step 2a: divide the upper part of the lower numerator by the upper part of the divisor
    // To get the numerator, complate the calculation of the full remainder by subtracing the quotient times the lower bits of the divisor
    // TODO: a warpping subtract is necessary here. why does this work, and why is it necessary?
    </span><span class="kw">let </span>full_remainder_hi = ((partial_remainder_hi &lt;&lt; <span class="number">32</span>) | numerator_mid).wrapping_sub(quotient_hi * divisor_lo);

    <span class="kw">let </span><span class="kw-2">mut </span>quotient_lo = core::cmp::min(full_remainder_hi / divisor_hi, U32_MAX);
    <span class="kw">let </span><span class="kw-2">mut </span>partial_remainder_lo = full_remainder_hi - quotient_lo * divisor_hi;

    <span class="comment">// step 2b: just like step 1b, decrement the final quotient until it&#39;s correctr when accounting for the full divisor
    </span><span class="kw">while </span>partial_remainder_lo &lt;= U32_MAX &amp;&amp; quotient_lo * divisor_lo &gt; (partial_remainder_lo &lt;&lt; <span class="number">32</span>) | numerator_lo {
        quotient_lo -= <span class="number">1</span>;
        partial_remainder_lo += divisor_hi;
    }

    <span class="comment">// We now have our separate quotients, now we just have to add them together
    </span>(quotient_hi &lt;&lt; <span class="number">32</span>) | quotient_lo
}


<span class="comment">// Same as divide_128_by_64_into_64, but optimized for scenarios where the divisor fits in a u32. Still panics if the quotient doesn&#39;t fit in a u64
</span><span class="kw">fn </span>divide_128_by_32_helper(numerator: u128, divisor: u32) -&gt; u64 {
	<span class="comment">// Assert that the upper half of the numerator is less than the denominator. This will guarantee that the quotient fits inside the numerator.
	// Sadly this will give us some false negatives! TODO: Find a quick test we can do that doesn&#39;t have false negatives
	// false negative example: numerator = u64::MAX * u64::MAX / u64::MAX
	</span><span class="macro">assert!</span>(divisor <span class="kw">as </span>u64 &gt; (numerator &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64, <span class="string">&quot;The numerator is too large for the denominator; the quotient might not fit inside a u64.&quot;</span>);

    <span class="kw">let </span>shift_size = divisor.leading_zeros();
	<span class="kw">let </span>shifted_divisor = (divisor &lt;&lt; shift_size) <span class="kw">as </span>u64;
	<span class="kw">let </span>shifted_numerator = numerator &lt;&lt; (shift_size + <span class="number">32</span>);

    <span class="comment">// split the numerator into 3 chunks: the top 64-bits, the next 32-bits, and the lowest 32-bits
    </span><span class="kw">let </span>numerator_hi : u64 = (shifted_numerator &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64;
    <span class="kw">let </span>numerator_mid : u64 = (shifted_numerator &gt;&gt; <span class="number">32</span>) <span class="kw">as </span>u32 <span class="kw">as </span>u64;

    <span class="comment">// we&#39;re essentially going to do a long division algorithm with 2 divisions, one on numerator_hi &lt;&lt; 32 | numerator_mid, and the second on the remainder of the first | numerator_lo
    // but numerator_hi &lt;&lt; 32 | numerator_mid is a 96-bit number, and we only have 64 bits to work with. so instead we split the divisor into 2 chunks, and divde by the upper chunk, and then check against the lower chunk in a while loop

    // step 1: divide the top chunk of the numerator by the divisor
    // IDEALLY, we would divide (numerator_hi &lt;&lt; 32) | numerator_mid by shifted_divisor, but that would require a 128-bit numerator, which is the whole thing we&#39;re trying to avoid
    // so instead we&#39;re going to split the second division into two sub-phases. in 1a, we divide numerator_hi by divisor_hi, and then in 1b we decrement the quotient to account for the fact that it&#39;ll be smaller when you take divisor_lo into account

    // keep in mind that for all of step 1, the full numerator we&#39;re using will be
    // complete_first_numerator  = (numerator_hi &lt;&lt; 32) | numerator_mid

    // step 1a: divide the upper part of the middle numerator by the upper part of the divisor
    </span><span class="kw">let </span>quotient_hi = numerator_hi / shifted_divisor;
    <span class="kw">let </span>remainder_hi = numerator_hi - quotient_hi * shifted_divisor;

    <span class="comment">// step 2: Divide the bottom part of the numerator. We&#39;re going to have the same problem as step 1, where we want the numerator to be a 96-bit number, so again we&#39;re going to split it into 2 substeps
	// the full numeratoe for step 3 will be:
	// complete_second_numerator = (first_division_remainder &lt;&lt; 32) | numerator_lo

    // step 2a: divide the upper part of the lower numerator by the upper part of the divisor
    // To get the numerator, complate the calculation of the full remainder by subtracing the quotient times the lower bits of the divisor
    // TODO: a warpping subtract is necessary here. why does this work, and why is it necessary?
    </span><span class="kw">let </span>final_numerator = (remainder_hi) &lt;&lt; <span class="number">32 </span>| numerator_mid;
    <span class="kw">let </span>quotient_lo = final_numerator / shifted_divisor;

    <span class="comment">// We now have our separate quotients, now we just have to add them together
    </span>(quotient_hi &lt;&lt; <span class="number">32</span>) | quotient_lo
}

<span class="attr">#[inline(never)]
</span><span class="kw">fn </span>long_division(numerator_slice: <span class="kw-2">&amp;</span>[u64], reduced_divisor: <span class="kw-2">&amp;</span>StrengthReducedU64, quotient: <span class="kw-2">&amp;mut </span>[u64]) {
	<span class="kw">let </span><span class="kw-2">mut </span>remainder = <span class="number">0</span>;
	<span class="kw">for </span>(numerator_element, quotient_element) <span class="kw">in </span>numerator_slice.iter().zip(quotient.iter_mut()).rev() {
		<span class="kw">if </span>remainder &gt; <span class="number">0 </span>{
			<span class="comment">// Do one division that includes the running remainder and the upper half of this numerator element, 
			// then a second division for the first division&#39;s remainder combinedwith the lower half
			</span><span class="kw">let </span>upper_numerator = (remainder &lt;&lt; <span class="number">32</span>) | (<span class="kw-2">*</span>numerator_element &gt;&gt; <span class="number">32</span>);
			<span class="kw">let </span>(upper_quotient, upper_remainder) = StrengthReducedU64::div_rem(upper_numerator, <span class="kw-2">*</span>reduced_divisor);

			<span class="kw">let </span>lower_numerator = (upper_remainder &lt;&lt; <span class="number">32</span>) | (<span class="kw-2">*</span>numerator_element <span class="kw">as </span>u32 <span class="kw">as </span>u64);
			<span class="kw">let </span>(lower_quotient, lower_remainder) = StrengthReducedU64::div_rem(lower_numerator, <span class="kw-2">*</span>reduced_divisor);

			<span class="kw-2">*</span>quotient_element = (upper_quotient &lt;&lt; <span class="number">32</span>) | lower_quotient;
			remainder = lower_remainder;
		} <span class="kw">else </span>{
			<span class="comment">// The remainder is zero, which means we can take a shortcut and only do a single division!
			</span><span class="kw">let </span>(digit_quotient, digit_remainder) = StrengthReducedU64::div_rem(<span class="kw-2">*</span>numerator_element, <span class="kw-2">*</span>reduced_divisor);

			<span class="kw-2">*</span>quotient_element = digit_quotient;
			remainder = digit_remainder;
		}
	}
}

<span class="attr">#[inline]
</span><span class="kw">fn </span>normalize_slice(input: <span class="kw-2">&amp;mut </span>[u64]) -&gt; <span class="kw-2">&amp;mut </span>[u64] {
	<span class="kw">let </span>input_len = input.len();
	<span class="kw">let </span>trailing_zero_chunks = input.iter().rev().take_while(|e| <span class="kw-2">**</span>e == <span class="number">0</span>).count();
	<span class="kw-2">&amp;mut </span>input[..input_len - trailing_zero_chunks]
}

<span class="attr">#[inline]
</span><span class="kw">fn </span>is_slice_greater(a: <span class="kw-2">&amp;</span>[u64], b: <span class="kw-2">&amp;</span>[u64]) -&gt; bool {
    <span class="kw">if </span>a.len() &gt; b.len() {
        <span class="kw">return </span><span class="bool-val">true</span>;
    }
    <span class="kw">if </span>b.len() &gt; a.len() {
    	<span class="kw">return </span><span class="bool-val">false</span>;
    }

    <span class="kw">for </span>(<span class="kw-2">&amp;</span>ai, <span class="kw-2">&amp;</span>bi) <span class="kw">in </span>a.iter().zip(b.iter()).rev() {
        <span class="kw">if </span>ai &lt; bi {
            <span class="kw">return </span><span class="bool-val">false</span>;
        }
        <span class="kw">if </span>ai &gt; bi {
            <span class="kw">return </span><span class="bool-val">true</span>;
        }
    }
   	<span class="bool-val">false
</span>}
<span class="comment">// subtract b from a, and store the result in a
</span><span class="attr">#[inline]
</span><span class="kw">fn </span>sub_assign(a: <span class="kw-2">&amp;mut </span>[u64], b: <span class="kw-2">&amp;</span>[u64]) {
	<span class="kw">let </span><span class="kw-2">mut </span>borrow: i128 = <span class="number">0</span>;

	<span class="comment">// subtract b from a, keeping track of borrows as we go
	</span><span class="kw">let </span>(a_lo, a_hi) = a.split_at_mut(b.len());

	<span class="kw">for </span>(a, b) <span class="kw">in </span>a_lo.iter_mut().zip(b) {
		borrow += <span class="kw-2">*</span>a <span class="kw">as </span>i128;
		borrow -= <span class="kw-2">*</span>b <span class="kw">as </span>i128;
		<span class="kw-2">*</span>a = borrow <span class="kw">as </span>u64;
		borrow &gt;&gt;= <span class="number">64</span>;
	}

	<span class="comment">// We&#39;re done subtracting, we just need to finish carrying
	</span><span class="kw">let </span><span class="kw-2">mut </span>a_element = a_hi.iter_mut();
	<span class="kw">while </span>borrow != <span class="number">0 </span>{
		<span class="kw">let </span>a_element = a_element.next().expect(<span class="string">&quot;borrow underflow during sub_assign&quot;</span>);
		borrow += <span class="kw-2">*</span>a_element <span class="kw">as </span>i128;

		<span class="kw-2">*</span>a_element = borrow <span class="kw">as </span>u64;
		borrow &gt;&gt;= <span class="number">64</span>;
	}
}

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>divide_128_max_by_64(divisor: u64) -&gt; u128 {
	<span class="kw">let </span>quotient_hi = core::u64::MAX / divisor;
	<span class="kw">let </span>remainder_hi = core::u64::MAX - quotient_hi * divisor;

	<span class="kw">let </span>leading_zeros = divisor.leading_zeros();
	<span class="kw">let </span>quotient_lo = <span class="kw">if </span>leading_zeros &gt;= <span class="number">32 </span>{
		<span class="kw">let </span>numerator_mid = (remainder_hi &lt;&lt; <span class="number">32</span>) | core::u32::MAX <span class="kw">as </span>u64;
		<span class="kw">let </span>quotient_mid = numerator_mid / divisor;
		<span class="kw">let </span>remainder_mid = numerator_mid - quotient_mid * divisor;

		<span class="kw">let </span>numerator_lo = (remainder_mid &lt;&lt; <span class="number">32</span>) | core::u32::MAX <span class="kw">as </span>u64;
		<span class="kw">let </span>quotient_lo = numerator_lo / divisor;

		(quotient_mid &lt;&lt; <span class="number">32</span>) | quotient_lo
	}
	<span class="kw">else </span>{
		<span class="kw">let </span>numerator_hi = <span class="kw">if </span>leading_zeros &gt; <span class="number">0 </span>{ (remainder_hi &lt;&lt; leading_zeros) | (core::u64::MAX &gt;&gt; (<span class="number">64 </span>- leading_zeros)) } <span class="kw">else </span>{ remainder_hi };
		<span class="kw">let </span>numerator_lo = core::u64::MAX &lt;&lt; leading_zeros;

		divide_128_by_64_preshifted(numerator_hi, numerator_lo, divisor &lt;&lt; leading_zeros)
	};
	((quotient_hi <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>) | (quotient_lo <span class="kw">as </span>u128)
}

<span class="kw">fn </span>divide_256_max_by_32(divisor: u32) -&gt; (u128, u128) {
	<span class="kw">let </span>reduced_divisor = StrengthReducedU64::new(divisor <span class="kw">as </span>u64);
	<span class="kw">let </span><span class="kw-2">mut </span>numerator_chunks = [core::u64::MAX; <span class="number">4</span>];
	<span class="kw">let </span><span class="kw-2">mut </span>quotient_chunks = [<span class="number">0</span>; <span class="number">4</span>];
	long_division(<span class="kw-2">&amp;mut </span>numerator_chunks, <span class="kw-2">&amp;</span>reduced_divisor, <span class="kw-2">&amp;mut </span>quotient_chunks);

	<span class="comment">// quotient_chunks now contains the quotient! all we have to do is recombine it into u128s
	</span><span class="kw">let </span>quotient_lo = (quotient_chunks[<span class="number">0</span>] <span class="kw">as </span>u128) | ((quotient_chunks[<span class="number">1</span>] <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>);
	<span class="kw">let </span>quotient_hi = (quotient_chunks[<span class="number">2</span>] <span class="kw">as </span>u128) | ((quotient_chunks[<span class="number">3</span>] <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>);

	(quotient_hi, quotient_lo)
}

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>divide_256_max_by_128(divisor: u128) -&gt; (u128, u128) {
	<span class="kw">let </span>leading_zeros = divisor.leading_zeros();

	<span class="comment">// if the divisor fits inside a u32, we can use a much faster algorithm
	</span><span class="kw">if </span>leading_zeros &gt;= <span class="number">96 </span>{
		<span class="kw">return </span>divide_256_max_by_32(divisor <span class="kw">as </span>u32);
	}

	<span class="kw">let </span>empty_divisor_chunks = (leading_zeros / <span class="number">64</span>) <span class="kw">as </span>usize;
	<span class="kw">let </span>shift_amount = leading_zeros % <span class="number">64</span>;

	<span class="comment">// Shift the divisor and chunk it up into U32s
	</span><span class="kw">let </span>divisor_shifted = divisor &lt;&lt; shift_amount;
	<span class="kw">let </span>divisor_chunks = [
		divisor_shifted <span class="kw">as </span>u64,
		(divisor_shifted &gt;&gt; <span class="number">64</span>) <span class="kw">as </span>u64,
	];
	<span class="kw">let </span>divisor_slice = <span class="kw-2">&amp;</span>divisor_chunks[..(divisor_chunks.len() - empty_divisor_chunks)];

	<span class="comment">// We&#39;re gonna be doing a ton of u64/u64 divisions, so we&#39;re gonna eat our own dog food and set up a strength-reduced division instance
	// the only actual **divisions* we&#39;ll be doing will be with the largest 32 bits of the full divisor, not the full divisor
	</span><span class="kw">let </span>reduced_divisor_hi = StrengthReducedU64::new(<span class="kw-2">*</span>divisor_slice.last().unwrap() &gt;&gt; <span class="number">32</span>);
	<span class="kw">let </span>divisor_hi = <span class="kw-2">*</span>divisor_slice.last().unwrap();

	<span class="comment">// Build our numerator, represented by u32 chunks. at first it will be full of u32::MAX, but we will iteratively take chunks out of it as we divide
	</span><span class="kw">let </span><span class="kw-2">mut </span>numerator_chunks = [core::u64::MAX; <span class="number">5</span>];
	<span class="kw">let </span><span class="kw-2">mut </span>numerator_max_idx = <span class="kw">if </span>shift_amount &gt; <span class="number">0 </span>{
		numerator_chunks[<span class="number">4</span>] &gt;&gt;= <span class="number">64 </span>- shift_amount;
		numerator_chunks[<span class="number">0</span>] &lt;&lt;= shift_amount;
		<span class="number">5
	</span>}
	<span class="kw">else </span>{
		<span class="number">4
	</span>};

	<span class="comment">// allocate the biggest-possible quotient, even if it might be smaller -- we just won&#39;t fill out the biggest parts
	</span><span class="kw">let </span>num_quotient_chunks = <span class="number">3 </span>+ empty_divisor_chunks;
	<span class="kw">let </span><span class="kw-2">mut </span>quotient_chunks = [<span class="number">0</span>; <span class="number">4</span>];
	<span class="kw">for </span>quotient_idx <span class="kw">in </span>(<span class="number">0</span>..num_quotient_chunks).rev() {
		<span class="comment">/*
         * When calculating our next guess q0, we don&#39;t need to consider the digits below j
         * + b.data.len() - 1: we&#39;re guessing digit j of the quotient (i.e. q0 &lt;&lt; j) from
         * digit bn of the divisor (i.e. bn &lt;&lt; (b.data.len() - 1) - so the product of those
         * two numbers will be zero in all digits up to (j + b.data.len() - 1).
         */

        </span><span class="kw">let </span>numerator_slice = <span class="kw-2">&amp;mut </span>numerator_chunks[..numerator_max_idx];
     	<span class="kw">let </span>numerator_start_idx = quotient_idx + divisor_slice.len() - <span class="number">1</span>;
     	<span class="kw">if </span>numerator_start_idx &gt;= numerator_slice.len() {
            <span class="kw">continue</span>;
		}
		

		<span class="comment">// scope for borrow checker
		</span>{
			<span class="comment">// divide the uppermost bits of the remaining numerator to get &quot;sub_quotient&quot; which will be our guess for this quotient element
			</span><span class="kw">let </span>numerator_hi = <span class="kw">if </span>numerator_slice.len() - numerator_start_idx &gt; <span class="number">1 </span>{ numerator_slice[numerator_start_idx + <span class="number">1</span>] } <span class="kw">else </span>{ <span class="number">0 </span>};
			<span class="kw">let </span>numerator_lo = numerator_slice[numerator_start_idx];
			<span class="kw">let </span><span class="kw-2">mut </span>sub_quotient = divide_128_by_64_preshifted_reduced(numerator_hi, numerator_lo, reduced_divisor_hi, divisor_hi);

			<span class="kw">let </span><span class="kw-2">mut </span>tmp_product = [<span class="number">0</span>; <span class="number">3</span>];
			long_multiplication::long_multiply(<span class="kw-2">&amp;</span>divisor_slice, sub_quotient, <span class="kw-2">&amp;mut </span>tmp_product);
			<span class="kw">let </span>sub_product = normalize_slice(<span class="kw-2">&amp;mut </span>tmp_product);

			<span class="comment">// our sub_quotient is just a guess at the quotient -- it only accounts for the topmost bits of the divisor. when we take the bottom bits of the divisor into account, the actual quotient will be smaller
			// we will know if our guess is too large if (quotient_guess * full_divisor) (aka sub_product) is greater than this iteration&#39;s numerator slice. ifthat&#39;s the case, decrement it until it&#39;s less than or equal.
			</span><span class="kw">while </span>is_slice_greater(sub_product, <span class="kw-2">&amp;</span>numerator_slice[quotient_idx..]) {
				sub_assign(sub_product, <span class="kw-2">&amp;</span>divisor_slice);
				sub_quotient -= <span class="number">1</span>;
			}

			<span class="comment">// sub_quotient is now the correct sub-quotient for this iteration. add it to the full quotient, and subtract the product from the full numerator, so that what remains in the numerator is the remainder of this division
			</span>quotient_chunks[quotient_idx] = sub_quotient;
			sub_assign(<span class="kw-2">&amp;mut </span>numerator_slice[quotient_idx..], sub_product);
		}


		<span class="comment">// slice off any zeroes at the end of the numerator. we&#39;re not calling normalize_slice here because of borrow checker obnoxiousness
		</span>numerator_max_idx -= numerator_slice.iter().rev().take_while(|e| <span class="kw-2">**</span>e == <span class="number">0</span>).count();
	}

	
	<span class="comment">// quotient_chunks now contains the quotient! all we have to do is recombine it into u128s
	</span><span class="kw">let </span>quotient_lo = (quotient_chunks[<span class="number">0</span>] <span class="kw">as </span>u128)
		| ((quotient_chunks[<span class="number">1</span>] <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>);
	<span class="kw">let </span>quotient_hi = (quotient_chunks[<span class="number">2</span>] <span class="kw">as </span>u128)
		| ((quotient_chunks[<span class="number">3</span>] <span class="kw">as </span>u128) &lt;&lt; <span class="number">64</span>);

	(quotient_hi, quotient_lo)
}



<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>unit_tests {
	<span class="kw">use </span>num_bigint::BigUint;

	<span class="attr">#[test]
	</span><span class="kw">fn </span>test_divide_128_by_64() {
		<span class="kw">for </span>divisor <span class="kw">in </span>core::u64::MAX..=core::u64::MAX {
			<span class="kw">let </span>divisor_128 = core::u64::MAX <span class="kw">as </span>u128;

			<span class="kw">let </span>numerator = divisor_128 * divisor_128 + (divisor_128 - <span class="number">1</span>);
			<span class="comment">//for numerator in core::u128::MAX - 10..core::u128::MAX {
		        </span><span class="kw">let </span>expected_quotient = numerator / divisor <span class="kw">as </span>u128;
		        <span class="macro">assert!</span>(expected_quotient == core::u64::MAX <span class="kw">as </span>u128);

		        <span class="kw">let </span>actual_quotient = <span class="kw">super</span>::divide_128_by_64_helper(numerator <span class="kw">as </span>u128, divisor);

		        

		        <span class="kw">let </span>expected_upper = (expected_quotient &gt;&gt; <span class="number">32</span>) <span class="kw">as </span>u64;
		        <span class="kw">let </span>expected_lower = expected_quotient <span class="kw">as </span>u32 <span class="kw">as </span>u64;
		        <span class="kw">let </span>actual_upper = (actual_quotient &gt;&gt; <span class="number">32</span>) <span class="kw">as </span>u64;
		        <span class="kw">let </span>actual_lower = actual_quotient <span class="kw">as </span>u32 <span class="kw">as </span>u64;

		        <span class="macro">assert_eq!</span>(expected_upper, actual_upper, <span class="string">&quot;wrong quotient for {}/{}&quot;</span>, numerator, divisor);
		        <span class="macro">assert_eq!</span>(expected_lower, actual_lower, <span class="string">&quot;wrong quotient for {}/{}&quot;</span>, numerator, divisor);
		    <span class="comment">//}
	    </span>}
	}

	<span class="kw">fn </span>test_divisor_128(divisor: u128) {
		<span class="kw">let </span>big_numerator = BigUint::from_slice(<span class="kw-2">&amp;</span>[core::u32::MAX; <span class="number">8</span>]);
		<span class="kw">let </span>big_quotient = big_numerator / divisor;

		<span class="comment">//let (actual_hi, actual_lo) = super::divide_256_max_by_128_direct(divisor);
		</span><span class="kw">let </span>(actual64_hi, actual64_lo) = <span class="kw">super</span>::divide_256_max_by_128(divisor);

		<span class="comment">//let actual_big = (BigUint::from(actual_hi) &lt;&lt; 128) | BigUint::from(actual_lo);
		</span><span class="kw">let </span>actual64_big = (BigUint::from(actual64_hi) &lt;&lt; <span class="number">128</span>) | BigUint::from(actual64_lo);

		<span class="comment">//assert_eq!(big_quotient, actual_big, &quot;Actual quotient didn&#39;t match expected quotient for max/{}&quot;, divisor);
		</span><span class="macro">assert_eq!</span>(big_quotient, actual64_big, <span class="string">&quot;Actual64 quotient didn&#39;t match expected quotient for max/{}&quot;</span>, divisor);
	}

	<span class="attr">#[allow(unused_imports)]
	</span><span class="kw">use </span>rand::{rngs::StdRng, SeedableRng, distributions::Distribution, distributions::Uniform};

	<span class="attr">#[test]
	</span><span class="kw">fn </span>test_max_256() {
		<span class="kw">let </span>log2_tests_per_bit = <span class="number">6</span>;

		<span class="kw">for </span>divisor <span class="kw">in </span><span class="number">1</span>..(<span class="number">1 </span>&lt;&lt; log2_tests_per_bit) {
			test_divisor_128(divisor);
		}

		<span class="kw">let </span><span class="kw-2">mut </span>gen = StdRng::seed_from_u64(<span class="number">5673573</span>);
		<span class="kw">for </span>bits <span class="kw">in </span>log2_tests_per_bit..<span class="number">128 </span>{
			<span class="kw">let </span>lower_start = <span class="number">1 </span>&lt;&lt; bits;
			<span class="kw">let </span>lower_stop = lower_start + (<span class="number">1 </span>&lt;&lt; (log2_tests_per_bit - <span class="number">3</span>));
			<span class="kw">let </span>upper_stop = <span class="number">1u128</span>.checked_shl(bits + <span class="number">1</span>).map_or(core::u128::MAX, |v| v - <span class="number">1</span>);
			<span class="kw">let </span>upper_start = upper_stop - (<span class="number">1 </span>&lt;&lt; (log2_tests_per_bit - <span class="number">3</span>)) + <span class="number">1</span>;

			<span class="kw">for </span>divisor <span class="kw">in </span>lower_start..lower_stop {
				test_divisor_128(divisor);
			}
			<span class="kw">for </span>divisor <span class="kw">in </span>upper_start..=upper_stop {
				test_divisor_128(divisor);
			}

			<span class="kw">let </span>random_count = <span class="number">1 </span>&lt;&lt; log2_tests_per_bit;
			<span class="kw">let </span>dist = Uniform::new(lower_stop + <span class="number">1</span>, upper_start);
			<span class="kw">for _ in </span><span class="number">0</span>..random_count {
				<span class="kw">let </span>divisor = dist.sample(<span class="kw-2">&amp;mut </span>gen);
				test_divisor_128(divisor);
			}
		}
	}
}
</code></pre></div>
</section></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="strength_reduce" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0-nightly (f77bfb733 2023-03-01)" data-search-js="search-2cde8914278f97ed.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>